./core.py:18:#Parameters: no_of_transactions, lambda, no_of_agents, alpha, latency (h), tip_selection_algo
./core.py:30:#Parameters: no_of_transactions, lambda, no_of_agents, alpha, distance, tip_selection_algo
./core.py:52:    simu2 = Multi_Agent_Simulation(_no_of_transactions = txs, _lambda = lam,
./core.py:70:# print_tips_over_time_multiple_agents(simu2, simu2.no_of_transactions)
./core.py:71:# print_tips_over_time_multiple_agents_with_tangle(simu2, simu2.no_of_transactions)
./config.ini:2:no_of_transactions = 2000
./simulation/helpers.py:86:        if not all(key in simulation_config_parameters.keys() for key in ['no_of_transactions','lambda','no_of_agents',\
./simulation/helpers.py:90:            print("Parameter error! Please provide 'no_of_transactions','lambda','no_of_agents','alpha','latency',"
./simulation/helpers.py:95:        _no_of_transactions = int(simulation_config_parameters['no_of_transactions'])
./simulation/helpers.py:115:        data.append((_no_of_transactions, _lambda, _no_of_agents, \
./simulation/helpers.py:166:            #Write all other transactions
./simulation/simulation_multi_agent.py:22:    def __init__(self, _no_of_transactions, _lambda, _no_of_agents, \
./simulation/simulation_multi_agent.py:29:            self.no_of_transactions = self.config[0][0]
./simulation/simulation_multi_agent.py:41:            self.no_of_transactions = _no_of_transactions
./simulation/simulation_multi_agent.py:47:            self.total_num_tx = _no_of_transactions
./simulation/simulation_multi_agent.py:69:        self.transactions = []
./simulation/simulation_multi_agent.py:72:        self.not_visible_transactions = []
./simulation/simulation_multi_agent.py:107:        inter_arrival_times = np.random.exponential(1 / self.lam, self.no_of_transactions)
./simulation/simulation_multi_agent.py:112:            num_of_milestones = int((self.no_of_transactions / self.lam) * self.lam_m)
./simulation/simulation_multi_agent.py:121:        self.transactions.append(Transaction(0, transaction_counter))
./simulation/simulation_multi_agent.py:122:        self.DG.add_node(self.transactions[0], pos=(0, 0), no=transaction_counter, node_color='#99ffff')
./simulation/simulation_multi_agent.py:128:            self.transactions.append(Transaction(self.arrival_times[i], transaction_counter))
./simulation/simulation_multi_agent.py:149:        for transaction in self.transactions[1:]:
./simulation/simulation_multi_agent.py:177:            #Update weights (of transactions referenced by the current transaction)
./simulation/simulation_multi_agent.py:244:    def get_visible_transactions(self, incoming_transaction_time, incoming_transaction_agent):
./simulation/simulation_multi_agent.py:247:        self.not_visible_transactions = []
./simulation/simulation_multi_agent.py:249:            agent.visible_transactions = []
./simulation/simulation_multi_agent.py:251:        #Loop through all transactions in DAG
./simulation/simulation_multi_agent.py:254:            #For EACH agent record the currently visible and not visible transactions
./simulation/simulation_multi_agent.py:260:                    agent.visible_transactions.append(transaction)
./simulation/simulation_multi_agent.py:269:                        agent.visible_transactions.append(transaction)
./simulation/simulation_multi_agent.py:271:                    #Record not visible transactions for 'current agent' only (reduces overhead)
./simulation/simulation_multi_agent.py:273:                        self.not_visible_transactions.append(transaction)
./simulation/simulation_multi_agent.py:280:        for transaction in agent.visible_transactions:
./simulation/simulation_multi_agent.py:296:        return set(list(self.DG.predecessors(transaction))).issubset(set(self.not_visible_transactions))
./simulation/simulation_multi_agent.py:322:                self.get_visible_transactions(transaction.arrival_time, agent)
./simulation/simulation_multi_agent.py:326:        #Get visible transactions and valid tips (and record these)
./simulation/simulation_multi_agent.py:327:        self.get_visible_transactions(transaction.arrival_time, transaction.agent)
./simulation/simulation_multi_agent.py:351:        return self.transactions[tx_idx]
./simulation/simulation_multi_agent.py:363:                self.get_visible_transactions(transaction.arrival_time, agent)
./simulation/simulation_multi_agent.py:367:        #Get visible transactions and valid tips (and record these)
./simulation/simulation_multi_agent.py:368:        self.get_visible_transactions(transaction.arrival_time, transaction.agent)
./simulation/simulation_multi_agent.py:386:        walker_on = self.transactions[0]
./simulation/simulation_multi_agent.py:395:            visible_approvers = common_elements(approvers, transaction.agent.visible_transactions)
./simulation/simulation_multi_agent.py:412:                self.get_visible_transactions(transaction.arrival_time, agent)
./simulation/simulation_multi_agent.py:416:        #Get visible transactions and valid tips (and record these)
./simulation/simulation_multi_agent.py:417:        self.get_visible_transactions(transaction.arrival_time, transaction.agent)
./simulation/simulation_multi_agent.py:423:        tip1 = self.weighted_random_walk(transaction, valid_tips, self.transactions[0])
./simulation/simulation_multi_agent.py:424:        tip2 = self.weighted_random_walk(transaction, valid_tips, self.transactions[0])
./simulation/simulation_multi_agent.py:436:                self.get_visible_transactions(transaction.arrival_time, agent)
./simulation/simulation_multi_agent.py:440:        # Get visible transactions and valid tips (and record these)
./simulation/simulation_multi_agent.py:441:        self.get_visible_transactions(transaction.arrival_time, transaction.agent)
./simulation/simulation_multi_agent.py:461:        # walker_on = self.transactions[0]
./simulation/simulation_multi_agent.py:470:            visible_approvers = common_elements(approvers, transaction.agent.visible_transactions)
./simulation/simulation_multi_agent.py:494:                    if transaction in agent.visible_transactions:
./simulation/simulation_multi_agent.py:502:            #Reset exit probability of all transactions to 0%, just needed when run multiple times throughout simulation
./simulation/simulation_multi_agent.py:507:            self.transactions[0].exit_probability_multiple_agents[agent] = 1
./simulation/simulation_multi_agent.py:509:            #Determine visible transaction for t + 1, so that all transactions (h = 1) are included
./simulation/simulation_multi_agent.py:510:            self.get_visible_transactions(incoming_transaction.arrival_time + self.latency, agent)
./simulation/simulation_multi_agent.py:520:                if (transaction in agent.visible_transactions):
./simulation/simulation_multi_agent.py:524:                    visible_approvers = common_elements(approvers, agent.visible_transactions)
./simulation/simulation_multi_agent.py:536:        #Loop over agents and get visible transactions and valid tips
./simulation/simulation_multi_agent.py:538:            self.get_visible_transactions(incoming_transaction.arrival_time + self.latency, agent)
./simulation/simulation_multi_agent.py:541:            #Loop over visible transactions
./simulation/simulation_multi_agent.py:542:            for transaction in agent.visible_transactions:
./simulation/simulation_multi_agent.py:566:            self.get_visible_transactions(incoming_transaction.arrival_time + self.latency, agent)
./simulation/simulation_multi_agent.py:596:    #         #Get visible transactions and valid tips (and record these)
./simulation/simulation_multi_agent.py:597:    #         self.get_visible_transactions(incoming_transaction.arrival_time + self.latency, agent)
./simulation/plotting.py:12:    text = "\nParameters:  Transactions = " + str(self.no_of_transactions) + \
./simulation/plotting.py:36:    labels[self.transactions[0]] = str(np.round(self.transactions[0].exit_probability_multiple_agents[self.agents[0]],2))
./simulation/plotting.py:63:    title = "Transactions = " + str(self.no_of_transactions) +\
./simulation/plotting.py:86:    #Cut off first 250 transactions for mean and best fit
./simulation/plotting.py:87:    if(self.no_of_transactions >= 250):
./simulation/plotting.py:103:    title = "Transactions = " + str(self.no_of_transactions) + \
./simulation/plotting.py:113:def print_tips_over_time_multiple_agents_with_tangle(self, no_current_transactions):
./simulation/plotting.py:125:        plt.plot(self.arrival_times[:no_current_transactions], no_tips[:no_current_transactions], label=label, color=self.agent_colors[int(str(agent))])
./simulation/plotting.py:127:        #Cut off first 60% of transactions
./simulation/plotting.py:128:        if(no_current_transactions >= 500):
./simulation/plotting.py:129:            cut_off = int(no_current_transactions * 0.2)
./simulation/plotting.py:135:        # x_mean = [self.arrival_times[cut_off], self.arrival_times[no_current_transactions-1]]
./simulation/plotting.py:136:        # y_mean = [np.mean(no_tips[cut_off:no_current_transactions-1]), np.mean(no_tips[cut_off:no_current_transactions-1])]
./simulation/plotting.py:140:        # plt.plot(np.unique(self.arrival_times[cut_off:no_current_transactions-1]), \
./simulation/plotting.py:141:        # np.poly1d(np.polyfit(self.arrival_times[cut_off:no_current_transactions-1], no_tips[cut_off:no_current_transactions-1], 1))\
./simulation/plotting.py:142:        # (np.unique(self.arrival_times[cut_off:no_current_transactions-1])), label="Best Fit Line", linestyle='--')
./simulation/plotting.py:145:    title = "Transactions = " + str(self.no_of_transactions) + \
./simulation/plotting.py:168:    labels[self.transactions[0]] = str(np.round(self.transactions[0].exit_probability_multiple_agents[self.agents[0]],2))
./simulation/plotting.py:194:def print_tips_over_time_multiple_agents(self, no_current_transactions):
./simulation/plotting.py:205:        plt.plot(self.arrival_times[:no_current_transactions], no_tips[:no_current_transactions], label=label)#, color=self.agent_colors[int(str(agent))])
./simulation/plotting.py:207:        #Cut off first 60% of transactions
./simulation/plotting.py:208:        if(no_current_transactions >= 500):
./simulation/plotting.py:209:            cut_off = int(no_current_transactions * 0.2)
./simulation/plotting.py:215:        x_mean = [self.arrival_times[cut_off], self.arrival_times[no_current_transactions-1]]
./simulation/plotting.py:216:        y_mean = [np.mean(no_tips[cut_off:no_current_transactions-1]), np.mean(no_tips[cut_off:no_current_transactions-1])]
./simulation/plotting.py:221:        # plt.plot(np.unique(self.arrival_times[cut_off:no_current_transactions-1]), \
./simulation/plotting.py:222:        # np.poly1d(np.polyfit(self.arrival_times[cut_off:no_current_transactions-1], no_tips[cut_off:no_current_transactions-1], 1))\
./simulation/plotting.py:223:        # (np.unique(self.arrival_times[cut_off:no_current_transactions-1])), label="Best Fit Line", linestyle='--')
./simulation/plotting.py:226:    title = "Transactions = " + str(self.no_of_transactions) + \
./simulation/plotting.py:240:    title = "Transactions = " + str(self.no_of_transactions) + \
./simulation/plotting.py:279:    title = "Transactions = " + str(self.no_of_transactions) + \
./simulation/simulation.py:16:    def __init__(self, _no_of_transactions, _lambda, _no_of_agents, _alpha, _latency, _tip_selection_algo):
./simulation/simulation.py:17:        self.no_of_transactions = _no_of_transactions
./simulation/simulation.py:28:        self.transactions = []
./simulation/simulation.py:50:        inter_arrival_times = np.random.exponential(1 / self.lam, self.no_of_transactions)
./simulation/simulation.py:55:        self.transactions.append(Transaction(0, transaction_counter))
./simulation/simulation.py:56:        self.DG.add_node(self.transactions[0], pos=(0, 0), no=transaction_counter, node_color='#99ffff')
./simulation/simulation.py:62:            self.transactions.append(Transaction(self.arrival_times[i], transaction_counter))
./simulation/simulation.py:77:        for transaction in self.transactions[1:]:
./simulation/simulation.py:86:            #Update weights (of transactions referenced by the current transaction)
./simulation/simulation.py:90:            update_progress(int(str(transaction))/self.no_of_transactions, str(transaction))
./simulation/simulation.py:126:    def get_visible_transactions(self, incoming_transaction):
./simulation/simulation.py:128:        visible_transactions = []
./simulation/simulation.py:129:        not_visible_transactions = []
./simulation/simulation.py:137:                visible_transactions.append(transaction)
./simulation/simulation.py:140:                not_visible_transactions.append(transaction)
./simulation/simulation.py:142:        #print("Visible tips: " + str(visible_transactions))
./simulation/simulation.py:143:        return visible_transactions, not_visible_transactions
./simulation/simulation.py:146:    def get_valid_tips(self, visible_transactions, not_visible_transactions):
./simulation/simulation.py:150:        for transaction in visible_transactions:
./simulation/simulation.py:158:            elif(self.all_approvers_not_visible(transaction, not_visible_transactions)):
./simulation/simulation.py:165:    def all_approvers_not_visible(self, transaction, not_visible_transactions):
./simulation/simulation.py:166:        return set(self.DG.predecessors(transaction)).issubset(set(not_visible_transactions))
./simulation/simulation.py:189:        visible_transactions, not_visible_transactions = self.get_visible_transactions(transaction)
./simulation/simulation.py:190:        valid_tips = self.get_valid_tips(visible_transactions, not_visible_transactions)
./simulation/simulation.py:211:        start = self.transactions[0]
./simulation/simulation.py:226:        visible_transactions, not_visible_transactions = self.get_visible_transactions(transaction)
./simulation/simulation.py:227:        valid_tips = self.get_valid_tips(visible_transactions, not_visible_transactions)
./simulation/simulation.py:236:            visible_approvers = common_elements(approvers, visible_transactions)
./simulation/simulation.py:251:        start = self.transactions[0]
./simulation/simulation.py:266:        visible_transactions, not_visible_transactions = self.get_visible_transactions(transaction)
./simulation/simulation.py:267:        valid_tips = self.get_valid_tips(visible_transactions, not_visible_transactions)
./simulation/simulation.py:276:            visible_approvers = common_elements(approvers, visible_transactions)
./simulation/simulation.py:311:        self.transactions[0].exit_probability = 1.0
./simulation/agent.py:4:        self.visible_transactions = []
./cal_layered_conf_num.py:18:    This function finds all the indirect references for all of our transactions.
./cal_layered_conf_num.py:119:    # Find all the transactions that are confirmed by each milestone and their number.
./cal_layered_conf_num.py:159:        # # # # Store transactions confirmed by each milestone on each layer into csv files
./check_layered_conf_norm.py:88:    # ax.set_ylabel('Number of transactions confirmed in this layer')
./plot.py:21:    This function finds all the indirect references for all of our transactions.
./plot.py:129:    ax.set_title('No of transactions = 6000, lambda = {}, No of nodes = 20, Alpha = 0.001, Distance = 1, '
./plot.py:151:    ax.set_ylabel('Average number of transactions confirmed (TX/S)', fontsize=18)
./plot.py:200:    # Find all the transactions that are confirmed by each milestone and their number.
./plot.py:223:    # Plot transactions confirmed by each milestone on each layer
./plot.py:225:    # Plot the number of transactions confirmed by each milestone
